~.y[, from_stop := .x]))
all_departures <- rbindlist(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))
all_destinations <- rbindlist(trip_to_destinations, idcol = "trip_id")
# One massive join to get ALL possible connections
network <- all_reachable[
all_departures, on = "to_stop==from_stop", nomatch=0
][
all_destinations, on = "trip_id", nomatch=0
]
# One massive join to get ALL possible connections
network <- all_reachable[
all_departures, on = "to_stop==from_stop", nomatch=0, allow.cartesian = T
][
all_destinations, on = "trip_id", nomatch=0, allow.cartesian = T
]
# Pre-calculate ALL time constraints once
network[, minutes_until_limit := as.numeric(time_limit - departure_time)]
View(network)
reachable_stops_dict = synfaxgtfs:::.pkgenv$reachable_stops_dict
stop_to_departures = synfaxgtfs:::.pkgenv$stop_to_departures
trip_to_destinations = synfaxgtfs:::.pkgenv$trip_to_destinations
# Convert all lookups to flat tables
all_reachable <- map2_dfr(names(reachable_stops_dict), reachable_stops_dict,
~data.table(from_stop = .x, to_stop = unlist(.y)))
all_departures <- rbindlist(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))
all_destinations <- rbindlist(trip_to_destinations, idcol = "trip_id")
# One massive join to get ALL possible connections
network <- all_reachable[
all_departures, on = "to_stop==from_stop", nomatch=0, allow.cartesian = T
][
all_destinations, on = "trip_id", nomatch=0, allow.cartesian = T
]
# Pre-calculate ALL time constraints once
network[, minutes_until_limit := as.numeric(time_limit - departure_time)]
View(network)
View(all_departures)
View(all_destinations)
View(all_reachable)
all_departures <- rbindlist(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))
View(all_departures)
View(all_reachable)
all_departures <- map2_dfr(names(stop_to_departures), stop_to_departures,
function(stop_name, df) {
if(is.null(df) || nrow(df) == 0) return(NULL)
df$from_stop <- stop_name
return(df)
}, .id = NULL)
map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
})
all_departures <- bind_rows(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))
View(all_departures)
all_destinations <- bind_rows(trip_to_destinations, idcol = "trip_id")
all_destinations <- rbindlist(trip_to_destinations, idcol = "trip_id")
View(all_destinations)
all_destinations = bind_rows(trip_to_destinations)
# One massive join to get ALL possible connections
network <- all_reachable[
all_departures, on = "to_stop==from_stop", nomatch=0, allow.cartesian = T
][
all_destinations, on = "trip_id", nomatch=0, allow.cartesian = T
]
View(network)
View(network)
fast_place_registry <- function(network) {
network[, .(best_time = max(minutes_until_limit)),
by = .(from_stop, arrival_window, stop_id)]
}
# Pre-calculate ALL time constraints once
network[, minutes_until_limit := as.numeric(isochrone_params$time_limit_ - departure_time)]
fast_place_registry <- function(network) {
network[, .(best_time = max(minutes_until_limit)),
by = .(from_stop, arrival_window, stop_id)]
}
fast_place_registry <- network[, .(best_time = max(minutes_until_limit)),
by = .(from_stop, arrival_window, stop_id)]
fast_place_registry <- network[, .(best_time = max(minutes_until_limit)),
by = .(from_stop, stop_id)]
View(fast_place_registry)
# Convert all lookups to flat tables
all_reachable <- map2_dfr(names(reachable_stops_dict), reachable_stops_dict,
~data.table(from_stop = .x, to_stop = unlist(.y)))
View(all_reachable)
all_departures <- bind_rows(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))
View(all_departures)
all_departures <- bind_rows(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ - departure_time), 'minutes')]
View(all_departures)
View(all_destinations)
all_departures <- bind_rows(map2(names(stop_to_departures), stop_to_departures,
~{
dt <- as.data.table(.y)
dt[, from_stop := .x]
dt
}))
all_departures$minutes_until_limit = as.numeric(as.duration(isochrone_params$time_limit_ - all_departures$departure_time), 'minutes')
all_destinations = bind_rows(trip_to_destinations)
all_destinations$minutes_until_limit = as.numeric(as.duration(isochrone_params$time_limit_ - all_destinations$departure_time), 'minutes')
# One massive join to get ALL possible connections
network <- all_reachable[
all_departures, on = "to_stop==from_stop", nomatch=0, allow.cartesian = T
][
all_destinations, on = "trip_id", nomatch=0, allow.cartesian = T
]
fast_place_registry <- network[, .(best_time = max(minutes_until_limit)),
by = .(from_stop, stop_id)]
View(fast_place_registry)
fast_place_registry[fast_place_registry$stop_id == '14315'] %>% view()
fast_place_registry[fast_place_registry$from_stop == '14315'] %>% view()
# Level 0: Direct trips (no transfers)
direct_connections <- map2_dfr(names(stop_to_departures), stop_to_departures,
function(stop_name, departures_df) {
if(is.null(departures_df) || nrow(departures_df) == 0) return(NULL)
# Get all destinations for trips from this stop
trip_destinations <- map_dfr(departures_df$trip_id, function(trip) {
dest_df <- trip_to_destinations[[trip]]
if(is.null(dest_df)) return(NULL)
# Convert Period to minutes and add metadata
dest_df %>%
mutate(
departure_time_min = as.numeric(departure_time, "minutes"),
from_stop = stop_name,
trip_id = trip,
transfer_level = 0L,
penalty_adjusted_time = as.numeric(minutes_until_time_limit, "minutes")
)
})
return(trip_destinations)
})
# Level 0: Direct trips (no transfers)
direct_connections <- map2_dfr(names(stop_to_departures), stop_to_departures,
function(stop_name, departures_df) {
if(is.null(departures_df) || nrow(departures_df) == 0) return(NULL)
# Get all destinations for trips from this stop
trip_destinations <- map_dfr(departures_df$trip_id, function(trip) {
dest_df <- trip_to_destinations[[trip]]
if(is.null(dest_df)) return(NULL)
# Calculate minutes_until_time_limit and convert Period to minutes
dest_df %>%
mutate(
departure_time_min = as.numeric(departure_time, "minutes"),
minutes_until_time_limit = as.numeric(as.duration(time_limit - departure_time), "minutes"),
from_stop = stop_name,
trip_id = trip,
transfer_level = 0L,
penalty_adjusted_time = minutes_until_time_limit  # No penalty for direct
)
})
return(trip_destinations)
})
time_limit = isochrone_params$time_limit_
# Level 0: Direct trips (no transfers)
direct_connections <- map2_dfr(names(stop_to_departures), stop_to_departures,
function(stop_name, departures_df) {
if(is.null(departures_df) || nrow(departures_df) == 0) return(NULL)
# Get all destinations for trips from this stop
trip_destinations <- map_dfr(departures_df$trip_id, function(trip) {
dest_df <- trip_to_destinations[[trip]]
if(is.null(dest_df)) return(NULL)
# Calculate minutes_until_time_limit and convert Period to minutes
dest_df %>%
mutate(
departure_time_min = as.numeric(departure_time, "minutes"),
minutes_until_time_limit = as.numeric(as.duration(time_limit - departure_time), "minutes"),
from_stop = stop_name,
trip_id = trip,
transfer_level = 0L,
penalty_adjusted_time = minutes_until_time_limit  # No penalty for direct
)
})
return(trip_destinations)
})
View(direct_connections)
# Level 1: One transfer connections
one_transfer <- map2_dfr(names(reachable_stops_dict), reachable_stops_dict,
function(origin_stop, reachable_stops) {
if(is.null(reachable_stops)) return(NULL)
# For each reachable transfer stop
map_dfr(reachable_stops, function(transfer_stop) {
transfer_departures <- stop_to_departures[[as.character(transfer_stop)]]
if(is.null(transfer_departures)) return(NULL)
# Get destinations from transfer stop
map_dfr(transfer_departures$trip_id, function(trip) {
dest_df <- trip_to_destinations[[trip]]
if(is.null(dest_df)) return(NULL)
dest_df %>%
mutate(
departure_time_min = as.numeric(departure_time, "minutes"),
minutes_until_time_limit = as.numeric(as.duration(time_limit - departure_time), "minutes"),
from_stop = origin_stop,
via_stop = transfer_stop,
trip_id = trip,
transfer_level = 1L,
penalty_adjusted_time = minutes_until_time_limit - xfer_penalty_m
)
})
})
})
xfer_penalty_m = 5
tic()
time_limit = isochrone_params$time_limit_
# Level 0: Direct trips (no transfers)
direct_connections <- map2_dfr(names(stop_to_departures), stop_to_departures,
function(stop_name, departures_df) {
if(is.null(departures_df) || nrow(departures_df) == 0) return(NULL)
# Get all destinations for trips from this stop
trip_destinations <- map_dfr(departures_df$trip_id, function(trip) {
dest_df <- trip_to_destinations[[trip]]
if(is.null(dest_df)) return(NULL)
# Calculate minutes_until_time_limit and convert Period to minutes
dest_df %>%
mutate(
departure_time_min = as.numeric(departure_time, "minutes"),
minutes_until_time_limit = as.numeric(as.duration(time_limit - departure_time), "minutes"),
from_stop = stop_name,
trip_id = trip,
transfer_level = 0L,
penalty_adjusted_time = minutes_until_time_limit  # No penalty for direct
)
})
return(trip_destinations)
})
# Level 1: One transfer connections
one_transfer <- map2_dfr(names(reachable_stops_dict), reachable_stops_dict,
function(origin_stop, reachable_stops) {
if(is.null(reachable_stops)) return(NULL)
# For each reachable transfer stop
map_dfr(reachable_stops, function(transfer_stop) {
transfer_departures <- stop_to_departures[[as.character(transfer_stop)]]
if(is.null(transfer_departures)) return(NULL)
# Get destinations from transfer stop
map_dfr(transfer_departures$trip_id, function(trip) {
dest_df <- trip_to_destinations[[trip]]
if(is.null(dest_df)) return(NULL)
dest_df %>%
mutate(
departure_time_min = as.numeric(departure_time, "minutes"),
minutes_until_time_limit = as.numeric(as.duration(time_limit - departure_time), "minutes"),
from_stop = origin_stop,
via_stop = transfer_stop,
trip_id = trip,
transfer_level = 1L,
penalty_adjusted_time = minutes_until_time_limit - xfer_penalty_m
)
})
})
})
doParallel = F
num_cores = 1
# Convert all lookup tables to data.table for consistency
reachable_stops_dt <- rbindlist(lapply(names(.pkgenv$reachable_stops_dict), function(x) {
data.table(from_stop = x, to_stop = .pkgenv$reachable_stops_dict[[x]])
}))
# Convert all lookup tables to data.table for consistency
reachable_stops_dt <- rbindlist(lapply(names(synfaxgtfs:::.pkgenv$reachable_stops_dict), function(x) {
data.table(from_stop = x, to_stop = synfaxgtfs:::.pkgenv$reachable_stops_dict[[x]])
}))
stop_to_departures_dt <- rbindlist(synfaxgtfs:::.pkgenv$stop_to_departures, idcol = "stop_id")
trip_to_destinations_dt <- rbindlist(synfaxgtfs:::.pkgenv$trip_to_destinations, idcol = "trip_id")
# Set keys for fast joins
setkey(reachable_stops_dt, from_stop)
setkey(stop_to_departures_dt, stop_id)
setkey(trip_to_destinations_dt, trip_id)
if(doParallel) {
plan(multisession, workers = num_cores)
}
# Process each stop
result <- future_map(unique_stops, function(current_stop_id) {
# Get reachable stops
transfer_stops <- reachable_stops_dt[from_stop == current_stop_id, to_stop]
if(length(transfer_stops) == 0) return(NULL)
# Get all departures from transfer stops
departures <- stop_to_departures_dt[stop_id %in% transfer_stops]
departures[, minutes_until_limit := as.numeric(difftime(isochrone_params$time_limit_,
departure_time, units = "mins"))]
# Get all destinations from these trips
destinations <- trip_to_destinations_dt[trip_id %in% departures$trip_id]
# Join to get the transfer stop for each trip
destinations[departures, transfer_stop := i.stop_id, on = "trip_id"]
# Filter to only stops after the transfer
destinations <- destinations[destinations[, .I[stop_sequence >= min(stop_sequence[stop_id == transfer_stop])], by = trip_id]$V1]
# Calculate time remaining
destinations[, minutes_until_limit := as.numeric(difftime(isochrone_params$time_limit_,
departure_time, units = "mins"))]
# Get arrival times at current stop
arrival_times <- .pkgenv$arrival_time_dict[[as.character(current_stop_id)]]
arrival_minutes <- as.numeric(difftime(isochrone_params$time_limit_, arrival_times, units = "mins"))
# For each arrival time, find valid destinations
result_list <- lapply(arrival_minutes, function(arr_time) {
valid_deps <- departures[minutes_until_limit > arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
})
names(result_list) <- as.character(arrival_minutes)
return(result_list)
}, .progress = TRUE)
# Process each stop
result <- future_map(unique_stops, function(current_stop_id) {
# Get reachable stops
transfer_stops <- reachable_stops_dt[from_stop == current_stop_id, to_stop]
if(length(transfer_stops) == 0) return(NULL)
# Get all departures from transfer stops
departures <- stop_to_departures_dt[stop_id %in% transfer_stops]
departures[, minutes_until_limit := as.numeric(difftime(isochrone_params$time_limit_,
departure_time, units = "mins"))]
# Get all destinations from these trips
destinations <- trip_to_destinations_dt[trip_id %in% departures$trip_id]
# Join to get the transfer stop for each trip
destinations[departures, transfer_stop := i.stop_id, on = "trip_id"]
# Filter to only stops after the transfer
destinations <- destinations[destinations[, .I[stop_sequence >= min(stop_sequence[stop_id == transfer_stop])], by = trip_id]$V1]
# Calculate time remaining
destinations[, minutes_until_limit := as.numeric(difftime(isochrone_params$time_limit_,
departure_time, units = "mins"))]
# Get arrival times at current stop
arrival_times <- synfaxgtfs:::.pkgenv$arrival_time_dict[[as.character(current_stop_id)]]
arrival_minutes <- as.numeric(difftime(isochrone_params$time_limit_, arrival_times, units = "mins"))
# For each arrival time, find valid destinations
result_list <- lapply(arrival_minutes, function(arr_time) {
valid_deps <- departures[minutes_until_limit > arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
})
names(result_list) <- as.character(arrival_minutes)
return(result_list)
}, .progress = TRUE)
names(result) <- unique_stops
result[['14315']]
result['14315']
warnings()
doParallel = T
num_cores = 8
reachable_stops_dt <- rbindlist(lapply(names(synfaxgtfs:::.pkgenv$reachable_stops_dict), function(x) {
data.table(from_stop = x, to_stop = synfaxgtfs:::.pkgenv$reachable_stops_dict[[x]])
}))
stop_to_departures_dt <- rbindlist(synfaxgtfs:::.pkgenv$stop_to_departures, idcol = "stop_id")
trip_to_destinations_dt <- rbindlist(synfaxgtfs:::.pkgenv$trip_to_destinations, idcol = "trip_id")
# Set keys for fast joins
setkey(reachable_stops_dt, from_stop)
setkey(stop_to_departures_dt, stop_id)
setkey(trip_to_destinations_dt, trip_id)
if(doParallel) {
plan(multisession, workers = num_cores)
}
# Process each stop
result <- future_map(unique_stops, function(current_stop_id) {
# Get reachable stops
transfer_stops <- reachable_stops_dt[from_stop == current_stop_id, to_stop]
if(length(transfer_stops) == 0) return(NULL)
# Get all departures from transfer stops
departures <- stop_to_departures_dt[stop_id %in% transfer_stops]
departures[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time), "minutes")]
# Get all destinations from these trips
destinations <- trip_to_destinations_dt[trip_id %in% departures$trip_id]
# Join to get the transfer stop for each trip
destinations[departures, transfer_stop := i.stop_id, on = "trip_id"]
# Filter to only stops after the transfer
destinations <- destinations[destinations[, .I[stop_sequence >= min(stop_sequence[stop_id == transfer_stop])], by = trip_id]$V1]
# Calculate time remaining
destinations[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time),"minutes")]
# Get arrival times at current stop
arrival_times <- synfaxgtfs:::.pkgenv$arrival_time_dict[[as.character(current_stop_id)]]
arrival_minutes <- as.numeric(as.duration(isochrone_params$time_limit_ - arrival_times), "mins")
# For each arrival time, find valid destinations
result_list <- lapply(arrival_minutes, function(arr_time) {
valid_deps <- departures[minutes_until_limit > arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
})
names(result_list) <- as.character(arrival_minutes)
return(result_list)
}, .progress = TRUE)
# Process each stop
result <- future_map(unique_stops, function(current_stop_id) {
# Get reachable stops
transfer_stops <- reachable_stops_dt[from_stop == current_stop_id, to_stop]
if(length(transfer_stops) == 0) return(NULL)
# Get all departures from transfer stops
departures <- stop_to_departures_dt[stop_id %in% transfer_stops]
departures[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time), "minutes")]
# Get all destinations from these trips
destinations <- trip_to_destinations_dt[trip_id %in% departures$trip_id]
# Join to get the transfer stop for each trip
destinations[departures, transfer_stop := i.stop_id, on = "trip_id"]
# Filter to only stops after the transfer
destinations <- destinations[destinations[, .I[stop_sequence >= min(stop_sequence[stop_id == transfer_stop])], by = trip_id]$V1]
# Calculate time remaining
destinations[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time),"minutes")]
# Get arrival times at current stop
arrival_times <- synfaxgtfs:::.pkgenv$arrival_time_dict[[as.character(current_stop_id)]]
arrival_minutes <- as.numeric(as.duration(isochrone_params$time_limit_ - arrival_times), "minutes")
# For each arrival time, find valid destinations
result_list <- lapply(arrival_minutes, function(arr_time) {
valid_deps <- departures[minutes_until_limit > arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
})
names(result_list) <- as.character(arrival_minutes)
return(result_list)
}, .progress = TRUE)
current_stop_id = '14315'
# Get reachable stops
transfer_stops <- reachable_stops_dt[from_stop == current_stop_id, to_stop]
if(length(transfer_stops) == 0) return(NULL)
# Get all departures from transfer stops
departures <- stop_to_departures_dt[stop_id %in% transfer_stops]
departures[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time), "minutes")]
# Get all destinations from these trips
destinations <- trip_to_destinations_dt[trip_id %in% departures$trip_id]
# Join to get the transfer stop for each trip
destinations[departures, transfer_stop := i.stop_id, on = "trip_id"]
# Filter to only stops after the transfer
destinations <- destinations[destinations[, .I[stop_sequence >= min(stop_sequence[stop_id == transfer_stop])], by = trip_id]$V1]
# Calculate time remaining
destinations[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time),"minutes")]
# Get arrival times at current stop
arrival_times <- synfaxgtfs:::.pkgenv$arrival_time_dict[[as.character(current_stop_id)]]
arrival_minutes <- as.numeric(as.duration(isochrone_params$time_limit_ - arrival_times), "minutes")
# For each arrival time, find valid destinations
result_list <- lapply(arrival_minutes, function(arr_time) {
valid_deps <- departures[minutes_until_limit > arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
})
warnings()
View(result_list)
arr_time = arrival_minutes[1]
valid_deps <- departures[minutes_until_limit > arr_time]
valid_deps <- departures[minutes_until_limit < arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
# For each arrival time, find valid destinations
result_list <- lapply(arrival_minutes, function(arr_time) {
valid_deps <- departures[minutes_until_limit < arr_time]
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = max(minutes_until_limit)), by = stop_id]
})
View(result_list)
destinations[trip_id %in% valid_deps$trip_id & minutes_until_limit < arr_time
][, .(minutes_until_limit = min(minutes_until_limit)), by = stop_id]
# Get reachable stops
transfer_stops <- reachable_stops_dt[from_stop == current_stop_id, to_stop]
if(length(transfer_stops) == 0) return(NULL)
# Get all departures from transfer stops
departures <- stop_to_departures_dt[stop_id %in% transfer_stops]
departures[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time), "minutes")]
# Get all destinations from these trips
destinations <- trip_to_destinations_dt[trip_id %in% departures$trip_id]
# Join to get the transfer stop for each trip
destinations[departures, transfer_stop := i.stop_id, on = "trip_id"]
# Filter to only stops after the transfer
destinations <- destinations[destinations[, .I[stop_sequence >= min(stop_sequence[stop_id == transfer_stop])], by = trip_id]$V1]
# Calculate time remaining
destinations[, minutes_until_limit := as.numeric(as.duration(isochrone_params$time_limit_ -
departure_time),"minutes")]
View(destinations)
reachable_stops_dt <- bind_rows(lapply(names(synfaxgtfs:::.pkgenv$reachable_stops_dict), function(x) {
data.table(from_stop = x, to_stop = synfaxgtfs:::.pkgenv$reachable_stops_dict[[x]])
}))
stop_to_departures_dt <- bind_rows(synfaxgtfs:::.pkgenv$stop_to_departures, idcol = "stop_id")
stop_to_departures_dt <- bind_rows(synfaxgtfs:::.pkgenv$stop_to_departures)
trip_to_destinations_dt <- bind_rows(synfaxgtfs:::.pkgenv$trip_to_destinations)
# Set keys for fast joins
setkey(reachable_stops_dt, from_stop)
setkey(stop_to_departures_dt, stop_id)
setkey(trip_to_destinations_dt, trip_id)
# Set keys for fast joins
setkey(reachable_stops_dt, from_stop)
setkey(setDT(stop_to_departures_dt), stop_id)
View(stop_to_departures_dt)
View(stop_to_departures_dt)
stop_to_departures_dt <- rbindlist(synfaxgtfs:::.pkgenv$stop_to_departures, idcol = "stop_id")
View(stop_to_departures_dt)
